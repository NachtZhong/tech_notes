# 数据结构笔记

## 一、绪论

### 1. 数据结构的概念

数据结构包括三方面的内容: 逻辑结构, 存储结构和数据的运算, 一个算法的设计取决于所选定的逻辑结构, 一个算法的实现依赖于所采用的存储结构

#### 1.1 数据的逻辑结构

数据的逻辑结构指的是数据元素之间的逻辑关系, 可以分为线性结构和非线性结构, 线性表是典型的线性结构, 集合, 树和图是典型的非线性结构

- 集合: 结构中的元素除了同属一个集合外, 没有别的关系
- 线性结构: 结构中的数据元素之间只存在一对一的关系
- 树形结构: 结构中的数据元素存在一对多的关系
- 图状结构或网状结构: 结构中的数据元素存在多对多的关系



#### 1.2 数据的存储结构

数据的存储结构主要有以下四种:

- 顺序存储: 将逻辑上相连的元素存储在物理位置上也相邻的存储单元里, 元素之间的关系由存储单元的邻接关系来体现, 优点是可以实现随机存取, 每个元素占用最小的存储空间, 缺点是只能使用相邻的一块存储单元, 可能产生较多的外部碎片
- 链式存储: 不要求逻辑上相邻的元素在物理位置上也相邻, 借助指示元素存储地址的指针表示元素之间的逻辑关系, 优点是不会出现碎片现象, 缺点是每个元素因为存储指针会占用额外的存储空间, 并且只能实现顺序存取
- 索引存储: 在存储元素信息的同时, 建立附加的索引表, 优点是检索速度快, 缺点是增加了附加的索引表, 会占用较多的存储空间, 另外在新增和删除数据的时候要修改索引表, 所以相对会花费更多的时间
- 散列存储: 根据元素的关键字计算出该元素的存储地址, 又称为hash存储, 优点是检索, 增加和删除节点的操作都很快, 缺点是如果散列函数不好会出现元素存储单元的冲突, 解决冲突会增加时间和空间开销



### 2. 算法

#### 2.1 算法的基本概念

- 有穷性: 一个算法必须在执行有穷步后结束, 并且每一步都在有限的时间内完成
- 确定性: 算法的每一条指令必须有确定的含义, 同样的输入必须产生同样的输出 
- 可行性: 算法中描述的操作都是可以通过已经实现的基本操作执行有限次来实现的
- 输入: 算法有零个或者多个输入
- 输出: 算法有一个或多个输出

#### 2.2 算法的时间复杂度

1. 假设一个算法需要执行的次数的表达式为T(N)
2. 为了估算算法的运行时间和简化算法分析, 引入时间复杂度的概念. 首先定义：存在常数 c 和函数 f(N)，使得当 N >= c 时 T(N) <= f(N)，表示为 T(n) = O(f(n)) 。
3. 上述定义的意思是, 当输入N大于某个数的时候, f(n)的增长速度总是大于T(n)的, 那么我们就可以用f(n)来度量T(n)的增长速度, 也就是说某个算法的复杂度为O(f(n))
4. 算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。
5. 对于一个算法, 理论上可以选择无限个函数来度量他的增长速度, 但是取算法复杂度的时候只会取最接近的一个



#### 2.3 计算算法时间复杂度的方法

1. 当T(N)=c, c为一个常数的时候, 算法的复杂度为O(1), 当T(N)不为常数的时候, 将常数项省略
2. 当存在不同维度的项时, 忽略低项, 例如T(N) = n^3+n^2+29时, 算法复杂度为O(n^3)=>忽略低次项和常数项
3. 由于函数的阶数对增长速度的影响最显著, 所以与最高阶相乘的常数将会被忽略



   计算时间复杂度的常用技巧

- 对单个循环, 如果循环体的时间复杂度为n, 循环次数为m, 那么时间复杂度为O(m*n)
- 对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。分析的时候应该由里向外分析这些循环。
- 对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。
- 对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。



## 二、 线性表



### 1. 线性表的定义和基本操作

#### 1.1 定义

线性表是具有相同数据类型的n个数据元素的**有限序列**, 除了第一个元素之外, 每个元素有且仅有一个直接前驱, 除最后一个元素外, 每个元素有且只有一个直接后继, 需要注意的特点是

- 线性表的元素个数有限
- 线性表的元素具有逻辑上的顺序性, 在序列中各元素排序有先后次序
- 线性表中的元素的数据类型都相同, 每一个元素占有相同大小的存储空间
- 表中元素具有抽象性, 也就是只考虑元素间的逻辑关系, 不考虑元素表示什么内容

> 注意线性表是一种逻辑结构, 顺序表和链表是存储结构, 不要将两者混淆



#### 1.2 线性表的基本操作

- InitList: 初始化表, 构造一个空的线性表
- Length: 求表长
- LocateElem: 按值查找
- GetElem: 按索引查找
- ListInsert: 插入
- ListDelete: 删除
- PrintList: 输出表所有值
- Empty: 判空操作
- DestroyList: 销毁操作



### 2. 线性表的顺序表示

#### 2.1 顺序表的定义

线性表的顺序存储又称为顺序表, 它是用一组地址连续的存储单元, 依次存储线性表中的数据元素, 从而使得逻辑上相邻的两个元素在物理位置上也相邻, 顺序表的特点是表中元素的逻辑顺序与其物理顺序相同

一维数组可以是静态分配的, 也可以是动态分配的, 在静态分配的时候, 由于数组的大小和空间事先已经固定, 一旦空间沾满, 再加入新的数据将会产生溢出, 导致程序崩溃

而动态分配时, 存储的空间是在程序执行的过程中通过动态存储分配语句分配的, 一旦数据空间占满, 可以另外开辟一块更大的存储空间, 用来替换原来的存储空间, 但是要将整个数组的数据从旧存储空间迁移到新的存储空间

顺序表最大的特点是随机访问, 通过首地址和元素序号就可以在O(1)的时间内找到指定的元素

顺序表的存储密度高, 每个节点也只存储数据元素

顺序表逻辑上相邻的元素在物理上也相邻, 所以插入和删除操作需要移动大量元素



#### 2.2 顺序表基本操作的实现

##### a. 插入操作

在顺序表L的第i个位置插入新元素e, 如果i的输入不合法, 则返回false, 表示插入失败, 否则将顺序表的第i个元素以及其后的所有元素右移一个位置, 腾出一个空位置插入新元素e, 顺序表长度加一, 插入成功, 返回true

时间复杂度:

- 最好情况: 在表尾插入, 不需要移动元素, 时间复杂度为O(1)
- 最坏情况: 在表头插入, 元素后移语句被执行n次, 时间复杂度为O(n)
- 平均复杂度: O(n)

##### b. 删除操作

删除顺序表L中第i个位置的元素, 成功则返回true, 并将被删除的元素引用变量返回, 否则返回false

时间复杂度:

- 最好情况: 删除表尾元素, 不需要移动元素, 时间复杂度为O(1)
- 最坏情况: 删除表头元素, 移动除了第一个元素外的其他元素, 时间复杂度为O(n)
- 平均情况: O(n)

##### c. 按值查找

在顺序表中找第一个元素值等于e的元素, 并返回其位序

时间复杂度:

- 最好情况: 查找的元素就在表头, 时间复杂度O(1)
- 最坏情况: 查找的元素在表尾或者不存在, 时间复杂度为O(n)
- 平均情况: 时间复杂度为O(n)

### 3. 线性表的链式表示

链式存储线性表的时候, 不需要使用地址连续的存储单元, 不要求逻辑上连续的两个元素在物理位置上也相邻, 它是通过指针来建立起元素之间的逻辑关系, 因此, 对线性表的插入, 删除不需要移动元素, 只需要修改指针

#### 3.1 单链表

##### 定义

线性表的链式存储又称为单链表, 为了建立起元素之间的线性关系, 每个链表节点除了存放元素自身的信息之外, 还需要存放一个指向其后继的指针

利用单链表可以解决顺序表需要大量连续存储空间的缺点, 但是单链表附加了指针域, 存在浪费存储空间的缺点, 由于单链表的元素离散的分布在存储空间中, 所以单链表是非随机存取的存储结构, 也就是不能直接找到表中的某个点, 需要从表头开始遍历依次查找

通常用头指针来标识一个单链表, 头指针为NULL时表示一个空表, 为了操作上的方便, 在单链表的第一个结点之前附加一个结点, 成为头结点, 头结点的数据域可以不设任何信息, 也可以记录表长等相关信息, 头结点的指针域指向线性表的第一个元素结点

> 注意, 头结点和头指针的区别: 不管一个链表带没带头结点, 头指针始终指向链表中的第一个结点, 而头结点是带头结点链表中的第一个结点, 通常不存储信息

头结点的优点:

- 由于开始结点的位置在头结点的指针中, 链表第一个位置上的操作可以和表的其他位置上的操作保持一致, 无需进行特殊处理
- 无论链表是否为空, 头指针都是指向头结点的非空指针, 这样空表和非空表的处理也就统一了



##### 单链表上基本操作的实现

###### a. 头插法建立单链表

从一个空表开始, 生成新结点, 并将读取到的数据存储在新结点的数据域中, 然后将新结点插入当前链表的表头

采用头插法建立单链表读入数据的顺序和生成链表中元素的数据是相反的, 因为从链表头部插入数据, 每个结点插入的时间复杂度为O(1), 总的时间复杂度为O(n)

###### b. 尾插法建立单链表

如果希望链表中的数据和输入数据的顺序一致, 要采用尾插法, 为了减少插入数据的时间, 可以在链表中增加一个尾指针, 使其始终指向链表的尾结点, 由于有尾指针, 尾插法的时间复杂度和头插法一样, 都是O(n)

###### c. 按序号查找结点值

从单链表的第一个结点出发, 顺时针next域往下搜索, 直至找到第i个节点为止, 否则返回最后一个结点的指针域NULL

按序号查找操作的时间复杂度为O(n)

###### d. 按值查找表结点

从单链表第一个结点开始, 从前往后依次比较表中各结点数据域的值, 如果和给定值相等则返回该结点的指针, 如果整个链表没有符合条件的结点, 返回NULL

###### e. 插入结点操作

插入操作是将值为x的新结点插入到单链表的第i个位置上, 先检查插入位置的合法性, 然后找到待插入位置的前驱结点, 即是第i-1个结点, 再在它后面插入新结点

> 除了后插操作(常用), 还有一种前插操作, 是在某个结点的前面插入新结点, 这种情况可以先采用后插法在指定结点后面插入新结点, 再交换两者的数据, 这样可以达到前插的效果, 同时时间复杂度只有O(1)

###### f. 删除节点操作

删除操作是将单链表的第i个结点删除, 先检查删除位置的合法性, 然后查找表中第i-1个结点, 也就是被删除结点的前驱结点, 再将其删除(将要删除结点的前驱结点的next指针指向要删除结点的下一个结点)

> 如果要删除某个结点, 常规做法是从开头开始遍历找到它的前驱结点, 再删除该结点, 但是可以通过将其后驱结点赋值给要删除的结点, 再删除其后驱结点的方式来删除
>
> 假设三个结点为a,b,c,要删除的结点为b, 通常做法是将a的next指针指向c, 也可以将c的值赋给b, 然后删除c, 在可以获取到b的引用的情况下可以节省遍历链表前面部分的时间

###### g. 求表长操作

需遍历整个链表, 时间复杂度O(1), 注意如果链表有头结点, 头结点不纳入算数



##### 3.2 双链表

双链表是在单链表的基础上每个结点都加了一个指向前一个结点的指针, 按值查找和按位查找的时间复杂度和单链表一样, 但是在找某个结点的前驱结点的时候时间复杂度仅为O(1), 单链表为O(n)



##### 3.3 循环单链表

循环单链表和单链表的不同在于它的最后一个结点的next指针不是指向null而是指向头结点, 因此循环单链表的判空条件不是头结点的next指针是否为空, 而是它是否等于头指针

由于循环单链表是一个环, 它可以从表中的任一结点开始遍历整个链表, 在任何一个位置上的插入和删除操作都是等价的, 无需判断是否为表尾

在表头表尾操作比较多的情况下可以只设置尾指针, 这样对表头和表尾元素操作都只需要O(1)的时间复杂度(根据尾指针的next指针即可获得头指针)



##### 3.4 循环双链表

多了一个指向前驱结点指针的循环单链表



##### 3.5 静态链表

静态链表是借助数组来描述线性表的链式存储结构, 结点也有data和next两个域, 但是和链表中的指针不同的地方在于, 指针指向的不是下一个结点的内存地址, 而是下一个结点在数组中的下标(相对地址), 以next==-1作为结束的标志, 插入, 删除操作都和动态链表相同, 只需要修改指针, 不需要移动元素, 总体来说没有链表使用起来方便, 但是在一些不支持指针的高级语言里面, 是一种巧妙的设计方法

### 4. 顺序表和链表的比较

#### 4.1 存取方式

顺序表可以顺序存取, 也可以随机存取, 链表只能从表头顺序存取元素



#### 4.2 逻辑结构与物理结构

顺序表逻辑上相邻的元素在物理存储位置上也相邻, 链表逻辑上相邻的元素在物理存储的位置不一定相邻



#### 4.3 查找, 插入和删除操作

对于按值查找, 当顺序表在无序的情况下, 两者时间复杂度均为O(n), 顺序表有序的时候可以采用折半查找, 时间复杂度为O(log2n)

对于按序号查找, 顺序表时间复杂度为O(n), 链表复杂度为O(n)

对于插入和删除操作, 顺序表平均需要移动半个表长的数据, 而链表只需要移动指针即可



#### 4.4 存储空间的占用和分配

由于链表每个结点都带有指针域, 存储空间的占用相对较大, 而且存储密度相对顺序表而言不够大

顺序存储在静态分配情况下, 如果空间满了会出现内存溢出, 需要预先分配大量的内存空间, 但是可能会造成内存浪费, 在动态分配情况下, 可以扩充存储空间, 但是需要大块的连续存储空间(没有将导致分配失败), 而且分配完成后需要移动大量的元素, 效率较低

链式存储的结点空间只需要在使用的时候申请分配, 只要内存有空间就能分配, 灵活高效



### 5. 根据实际场景选用不同存储结构

- 当对线性表的长度或者存储规模无法估算时, 不宜采用顺序表
- 如果经常需要根据序号查询元素, 优先选择顺序表, 如果经常做插入/删除操作时, 优先选择列表
- 较为稳定的线性表选择顺序存储, 频繁做插入/删除操作的线性表(动态性较强)选择链式存储



