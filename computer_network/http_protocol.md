# HTTP协议

##   一、概述

### 1. TCP/IP协议的分层管理

TCP/IP协议族按照层次可以分为以下四层

- 应用层: 决定了向用户提供应用服务时通信的活动, TCP/IP协议族里面预存了各类通用的应用服务, 例如FTP和DNS
- 传输层: 传输层提供处于网络连接中的两台计算机之间的数据传输, 在传输层有两个性质不同的协议, TCP协议和UDP协议
- 网络层: 网络层用来处理在网络上流动的数据包, 数据包时网络传输的最小数据单位, 与对方计算机之间通过多台计算机或者网络设备进行通信的时候, 网络层所起的作用就是在不同的路线中选择一条相对较好的传输路线
- 链路层: 用来处理连接网络的硬件部分



发送端在层与层之间传递数据的时候每经过一层必定会打上这一层的首部信息, 反之, 接收端在层与层之间传递数据的时候每经过一层就会把对应的首部消去



### 与HTTP协议关系密切的协议

- IP协议: IP协议位于网络层, 作用是把各种数据包传送给对方, 而要保证确实传送到对方那里, 需要满足各类条件, 其中两个重要的条件是IP地址和MAC地址
- ARP协议: IP之间的通信依赖MAC地址, 在网络上, 通信的双方在同一局域网内情况较少, 一般来说需要进行中转, 在进行中转的时候会利用下一站中转设备的MAC地址来搜索下一个中转目标, 这时会采用ARP协议来通过IP地址反查出对应的MAC地址
- TCP协议: TCP协议位于传输层, 提供可靠的字节流服务, 为了方便传输, 该协议会将数据分割成报文段为单位的数据包进行管理, 为了准确无误的将数据送达目标处, TCP协议采用了三次握手策略, 握手过程中采用的TCP的标志SYN和ACK, 三次握手的过程如下
  1. 发送端发送一个带有SYN标志的数据包
  2. 接收端返回一个带有SYN/ACK标志的数据包
  3. 发送端发送一个带有ACK标志的数据包

- DNS服务: 提供通过域名查找IP地址的服务

## 二、HTTP协议简介

### 1. HTTP是不保存状态的协议

HTTP是一种无状态协议, 它自身不会对请求和相应之间的通信状态进行保存, 但是随着web的发展成熟, HTTP的这种无状态特性无法满足业务需求, 因此为了实现期望的保持状态, 引入了Cookie技术



### 2. HTTP/1.1支持的方法

- GET: 获取资源, 用来请求访问已经被URI识别的资源, 指定的资源经过服务端解析之后返回相应内容
- POST: 传输实体主体, 虽然GET方法也可以用来传输实体主体, 但是为了规范化, 该操作一般通过POST方法来进行
- PUT: 传输文件, 类似FTP的文件上传, 在请求报文的主体中包含文件内容, 然后保存到指定URI的位置, 但是由于HTTP/1.1的PUT方法不带验证机制, 任何人都可以上传文件, 因此一般的WEB网站不会开放这个方法
- DELETE: 和PUT相反, 用于删除文件, 同样由于没有安全机制, 较少支持
- HEAD: HEAD方法和GET方法一样, 只是不返回报文主体, 一般用于确认URI的有效性和资源更新的日期等
- OPTIONS: 用来查询针对请求URI指定的资源支持的方法
- TRACE: 在经过代理服务器转发的情况可以用这个方法来追踪请求的转发过程
- CONNECT: 使用隧道协议连接代理, 主要使用SSL和TLS协议把通信内容加密后经网络隧道传输



### 3. HTTP连接的持久性

一开始的HTTP协议每次进行一次通信就要断开一次连接, 后来由于web的发展, 需要传输的数据量上升, 频繁断开/连接会造成大量的资源浪费, 因此新版本的HTTP采用持久连接的方式来进行通信, 只要任意一端没有明确提出断开连接, TCP连接状态将会一直保持

> 持久连接让多数请求可以以管线化的方式进行, 也就是不需要等待上一个请求返回结果就可以继续发送下一个请求(异步)

### 4. 使用Cookie的状态管理

Cookie通过在请求和响应报文中加入Cookie值来控制客户端的状态, cookie的原理如下:

1. 客户端向服务端发送请求
2. 服务端生成Cookie, 并记住这个Cookie对应哪个客户端的映射信息
3. 服务端返回请求结果时在Set-Cookie的首部字段信息加入Cookie
4. 客户端保存Cookie
5. 第二次发送请求时, 客户端在请求中加入Cookie后发送出去
6. 服务端接收到请求后根据客户端发送的Cookie获取之前保存的对应客户端的状态信息

### 5. HTTP报文

HTTP报文大致可以分为报文首部和报文主体两块, 两者之间由第一次出现的空行来划分

请求报文和响应报文的结构如下:

- 请求报文
  - 请求行(包含请求的方法, 请求URI和HTTP版本)
  - 各种首部字段
  - 空行
  - 报文主体
- 响应报文
  - 状态行(响应结果的状态码, 原因短语和HTTP版本)
  - 各种首部字段
  - 空行
  - 报文主体

### 6. 传输过程中的编码

HTTP在传输数据的时候可以按照原来的数据直接进行传输, 也可以在传输过程中通过编码来提升传输速率, 这样在同样的时间内能处理更多的请求



## 三、HTTP状态码

### 1. 状态码的类别

状态码的第一个数字标识了该状态码的类别

- 1xx: 接收的请求正在处理
- 2xx: 请求正常处理完毕
- 3xx: 需要进行附加操作以完成请求
- 4xx: 服务器无法处理请求
- 5xx: 服务器请求处理出错



### 2. 2xx 成功



#### 2.1 200 OK

表示客户端发送过来的请求被正确处理了



#### 2.2 204 No Content

表示服务器接收的请求已经被正确处理, 但是在返回的响应报文中不包含实体的主体部分, 一般用于客户端向服务端发送信息, 而服务端不需要向客户端发送信息的情况下



#### 2.3 206 Partial Content

表示客户端进行了范围请求(每次只请求资源的一部分), 而服务器成功执行了这部分的GET请求



### 3. 3xx 重定向



#### 3.1 301 Moved Permanently

永久性重定向, 表示请求的资源已经被分配到了新的URI, 以后使用资源应该通过新的URI进行请求, 此时客户端应该根据Location首部字段的值(新URI)来重新进行保存



#### 3.2  302 Found

临时重定向, 表示请求的资源已经被分配了新的URI,希望用户本次能通过新的URI来进行访问, 注意的是它表示资源只是临时性质的被移动, 但是已经移动的资源可能在将来还会发生变化, 理论上来说应该询问用户后再确定是否要将POST请求转为GET请求来请求新URI的资源, 但是大部分浏览器并没有询问用户而是直接发起新的GET请求



#### 3.3 303 See Other

表示请求对应的资源存在另外一个URI, 应该使用GET来定向获取请求的资源, 它和302有着同样的功能, 但是它明确表示客户端应该使用GET方法来获取资源



#### 3.4 304 Not Modified

表示客户端发送附带条件的请求时(在请求的首部字段中添加验证条件), 服务端允许请求访问资源, 但是条件判断未满足, 返回报文状态码为304的时候, 返回报文不会携带任何主体数据, 只用于通知客户端请求中的判断条件未得到满足



#### 3.5 307 Temporary Redirect

临时重定向, 客户端应该根据Location字段中的URI重新发起POST请求(明确禁止从POST变成GET)



> 303和307实质上是新的HTTP标准对于旧的HTTP标准的细化(由于很多浏览器未遵循规定询问用户), 所以在302的基础上细化除了303和307, 303明确表明第二次请求使用GET, 307明确表明第二次请求使用POST



### 4. 4xx 客户端错误



#### 4.1 400 Bad Request

表示请求报文中存在语法错误, 客户端需要修改请求的内容后再次发送请求



#### 4.2 401 Unauthorized

表示正在发送的请求需要有通过HTTP验证的认证信息, 如果之前已经进行过一次请求, 那么这个结果码表示用户认证失败



#### 4.3 403 Forbidden

表示对请求资源的访问被服务器拒绝了, 服务器没必要告诉你为啥拒绝, 但是如果想说明的话, 可以在报文的主体部分进行说明



#### 4.4 404 Not Found

请求的资源在服务器上没有被找到



### 5. 5xx服务器错误



#### 5.1 500 Internal Server Error

表示服务器在执行请求的时候发生了错误, 可能是web应用存在bug或者临时性的故障



#### 5.2 503 Service Unavailable

表明服务器正在处于超负载或者正在停机维护, 无法处理请求



## 四、WEB服务器的功能

### 1. 通信数据转发程序

#### 1.1 代理

代理是一种带有转发功能的应用程序, 扮演在客户端和服务器的中间人角色, 接收客户端发送的请求并转发给服务器, 同时接收服务器返回的响应并且转发给客户端

使用代理服务器可以利用缓存技术来减少网络带宽的流量, 也可以实现组织内部针对特定网站的访问控制,  代理可以通过两个标准进行分类

- 是否进行缓存: 代理进行转发的时候, 缓存代理会预先将资源的副本缓存在代理服务器上, 当代理再次接收到相同的资源请求时就不必再次到服务器上面去请求, 而是直接返回缓存的资源数据
- 是否对报文进行加工: 不对报文做任何加工的代理称为透明代理, 反之被称为非透明代理



#### 1.2 网关

网关的工作原理和代理很相似, 但是网管可以使通信线路上的服务器提供非HTTP服务, 流程如下:

1. 客户端向网关发送HTTP请求
2. 网关向服务器发送非HTTP请求
3. 服务器向网关返回非HTTP响应
4. 网关向客户端返回HTTP响应

除此之外, 网关还可以在客户端和网关之间的通信线路上进行加密来提高通信的安全性



#### 1.3 隧道

隧道是在客户端和服务端之间建立起一条通信线路, 使用SSL等加密手段进行通信, 隧道的主要目的是为了安全, 隧道本身不会解析HTTP请求, 对客户端和服务器来说, 隧道是透明的



### 2. 缓存

#### 2.1 缓存服务器上的缓存

缓存服务器可以将资源缓存在自身, 当客户端请求相同资源的时候, 可以直接从缓存服务器返回数据, 可以有效减少相同的数据传输, 但是如果客户端明确要求或者缓存数据过期, 缓存服务器需要再次到服务器中请求最新的资源来更新缓存



#### 2.2 客户端的本地缓存

缓存也可以保存在客户端浏览器中, 如果浏览器缓存有效的话, 客户端可以直接在自身磁盘中获取资源数据, 与缓存服务器相同的一点是, 当浏览器判断自身缓存过期之后, 会向服务器确认资源的有效性, 如果确定资源已经失效, 则会重新请求最新的资源

























































